# Writeup — «Тьма»

## Идея
Подпись к задаче: **«Тьма содержит в себе все пороки»**. В стеганографии “тьма” часто намекает на то, что информация спрятана в **младших битах** (LSB / bit-planes), т.к. они почти не влияют на картинку и “незаметны”.

---

## Шаг 1. Достаём скрытую строку из младших битов

### Вариант A: StegSolve
1. Открываем `steg_2114_50.png` в **StegSolve**.
2. `Analyse → Bit Planes`.
3. Смотрим младшие биты (особенно **bit 0**, иногда полезно сводить каналы/смотреть несколько битов).

В одном из представлений появляется читаемая строка.

### Вариант B: простой скрипт
В папке `solve/` лежит скрипт `solve.py`, который строит визуализацию “low nibble” (4 младших бита) и сохраняет **зум** с текстом:

```bash
cd solve
python3 solve.py
# создаст clue_zoom.png
```

Откройте `solve/clue_zoom.png` — там читается:

```
16e6be5pl1t
```

---

## Шаг 2. Интерпретация подсказки
`pl1t` — это leet (1 → i), то есть читается как:

```
split
```

Получаем подсказку вида:

- **hex-кусок**: `16e6be5`
- слово: `split`

---

## Шаг 3. Находим пароль по hex-кусочку (MD5 substring)
`16e6be5` выглядит как часть hex-хэша. Самый частый формат в CTF — **MD5** (32 hex-символа).

Идея: найти такой пароль `X`, что `md5(X)` **содержит** подстроку `16e6be5`.
Это делается перебором по словарю (rockyou и т.п.).

Пример (python):

```python
import hashlib

needle = "16e6be5"
with open("rockyou.txt", "rb") as f:
    for w in f:
        w = w.strip()
        if not w:
            continue
        h = hashlib.md5(w).hexdigest()
        if needle in h:
            print(w.decode(errors="ignore"), h)
            break
```

Находится:

- пароль: `Pa55w0rd`
- md5: `c50672216e6be50f327c7df719784fe3` (внутри есть `16e6be5`)

Быстрая проверка:

```bash
echo -n "Pa55w0rd" | md5sum
# c50672216e6be50f327c7df719784fe3
```

---

## Шаг 4. Собираем флаг
По формату платформы флаг задаётся как `SplitCTF{...}`, а найденный “порок/пароль” — это `Pa55w0rd`.

**Флаг:**

```
SplitCTF{Pa55w0rd}
```
