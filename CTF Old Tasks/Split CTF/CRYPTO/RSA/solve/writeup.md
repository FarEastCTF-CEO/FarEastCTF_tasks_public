# Райтап: VeRY_Ea$y_RSA (RSA)

---

## Дано

Есть публичные параметры RSA (`n`, `e`) и шифртекст `ciphertext`.

В RSA шифрование устроено так:

- `c = m^e mod n`

Чтобы расшифровать и получить `m`, нужен приватный ключ `d`, где:

- `d = e^-1 mod φ(n)`
- `φ(n) = (p-1)(q-1)`, если `n = p*q`

---

## Идея

В CTF “easy RSA” почти всегда означает, что модуль `n` можно **факторизовать** (найти `p` и `q`) достаточно простым способом:

- через **FactorDB** (если модуль уже встречался/утёк);
- либо `yafu/msieve` (ECM), если один из множителей слабый или близкий к другому;
- иногда Fermat, если `p` и `q` близки.

После получения `p` и `q` остаётся стандартная математика RSA.

---

## Решение по шагам

1) Разложить `n` на множители: `n = p*q`  
2) Посчитать `φ(n) = (p-1)(q-1)`  
3) Найти `d = e^-1 mod φ(n)`  
4) Расшифровать: `m = c^d mod n`  
5) Перевести `m` в байты/строку и достать флаг

---

## Готовый шаблон кода (Python)

```python
from Crypto.Util.number import long_to_bytes, inverse

n = int("...")          # вставь n
e = int("...")          # вставь e
c = int("...")          # вставь ciphertext

p = int("...")          # найденный множитель
q = int("...")          # найденный множитель

phi = (p - 1) * (q - 1)
d = inverse(e, phi)

m = pow(c, d, n)
pt = long_to_bytes(m)

print(pt)
```

> Если вывод выглядит как `b'...'`, просто декодируй:
>
> ```python
> print(pt.decode())
> ```

---

## Результат

После факторизации `n` и расшифровки `ciphertext` получаем строку с флагом:

```
SplitCTF{VeRY_Ea$y_RSA}
```

---

## Флаг

**`SplitCTF{VeRY_Ea$y_RSA}`**
