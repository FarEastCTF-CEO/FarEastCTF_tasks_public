# supertask - writeup

## Идея задачи (что вообще происходит)
Это маленький GUI-exe, который делает проверку в **2 шага**.

1) На первом шаге он берёт 4 байта шифротекста, расшифровывает их твоим ключом и сравнивает с ожидаемой строкой `"stp1"`.
2) Если шаг 1 пройден, тем же ключом он расшифровывает **кусок кода** внутри `.text`, выполняет его, и тот код записывает “secret word”, который программа выводит.



## Где находится проверка (и что где лежит)

### Обработчик кнопки “Check”
Логика проверки сидит в функции по адресу **`0x4237B0`** (в IDA это выглядит как `sub_4237B0`).

Внутри неё важно вот что:

- Инициализация шифротекста шага 1 делается вызовом **`sub_423C60`**.  
  В **`sub_423C60`** лежит шифротекст в глобальных байтах **`byte_59D5D0..byte_59D5D3`**:  
  `85 F7 FE D3`.

- Строка, с которой сравнивают результат шага 1, лежит в глобале **`dword_548170`** (указатель на AnsiString).  
  Он указывает на строку **`"stp1"`** (в `.rdata`, видно как обычная ASCII).

- Нормализация ключа перед расшифровкой делается функцией **`sub_423FC0`**:  
  если длина ключа **нечётная**, она **добавляет в конец последний символ**, чтобы длина стала чётной.

- Расшифровка делается функцией **`sub_423ED0`** — она меняет буфер *на месте* (перед этим делает `VirtualProtect`, потому что иногда расшифровывает код).

После `sub_423ED0` идёт сравнение с `"stp1"`. Если не совпало — печать `"Wrong key. Step 1!"`. Если совпало — вызывается второй этап: **`sub_423D60`**.



## Алгоритм расшифровки (sub_423ED0)
Важно понимать ровно одну формулу. Ключ используется попарно: `(k0,k1), (k2,k3) …` и по кругу.

Для каждого байта шифротекста `c` вычисляется байт результата `p`:

`p = ((c XOR k[i]) - k[i+1]) mod 256`

Где `i` идёт 0,2,4,… и циклически повторяется по ключу.



## Как найти правильный ключ (Step 1 → фильтр Step 2)
### Шаг 1 задаёт уравнения
Здесь всё максимально маленькое: всего 4 байта шифротекста из `byte_59D5D0` должны превратиться в `"stp1"`.

То есть:
- `0x85` → `'s'`
- `0xF7` → `'t'`
- `0xFE` → `'p'`
- `0xD3` → `'1'`

Это даёт 4 независимые пары уравнений для `(k0,k1) (k2,k3) (k4,k5) (k6,k7)`.

Если ограничить перебор “человеческим” диапазоном (например `A–Z`), кандидатов получается немного (порядка десятков тысяч), и дальше их легко отфильтровать шагом 2.

### Фильтр по шагу 2
Шаг 2 расшифровывает блок по адресу **`loc_423CC0`**, и правильная расшифровка должна давать нормальный код. У этого кода ожидаемый пролог:

`55 89 E5 83 EC 08 89 45 FC 89 55 F8`

Перебираем кандидаты из шага 1 и оставляем тот, который расшифровывает первые 12 байт именно в такой пролог.

В результате остаётся ключ:

**`GOODKEYY`**

(он проходит Step 1 и корректно расшифровывает код Step 2)



## Второй этап: где лежит шифрокод и как из него достать флаг

### Где лежит шифрокод
- Адрес зашифрованного блока: **`loc_423CC0`** (в `.text`).
- Адрес берётся функцией **`sub_423C50`** (она просто возвращает `&loc_423CC0`).
- Длина берётся функцией **`sub_423C80`**: она ищет **10 подряд `0x90` (NOP)** как маркер конца и возвращает длину. Для этого бинаря получается **`0x90` (144 байта)**.

### Что делает sub_423D60
Функция **`sub_423D60`**:
1) вычисляет `ptr = sub_423C50()` → `loc_423CC0`
2) вычисляет `size = sub_423C80()` → `0x90`
3) вызывает `sub_423ED0(key, ptr, size)` — расшифровывает код на месте
4) вызывает расшифрованный `loc_423CC0(...)`

Расшифрованный `loc_423CC0` просто записывает в буфер байты:
`73 65 63 72 65 74 6B 65 79 21`, то есть строку:

**`secretkey!`**

А дальше основной код печатает:
`Here is the secret word: "%s".`



## Флаг
Фраза, которую выводит программа как secret word, необходимо обернуть в формат флага `FECTF{}`:

`FECTF{secretkey!}`

Пример кода для решения задачи представлен в файле `solver.py`
