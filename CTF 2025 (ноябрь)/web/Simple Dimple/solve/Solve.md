
Переходим на основную страницу сервиса,  видим поле авторизации и регистрации пользователя

![[Снимок экрана 2025-11-11 в 01.09.05.png]]

Создаем нового пользователя
![[Снимок экрана 2025-11-11 в 01.10.36.png]]


Заходим в созданную учётную запись и попадаем на основную страницу сервиса
![[Снимок экрана 2025-11-11 в 01.11.00.png]]
В Cookie замечаем JWT токен, посмотрим его содержимое
![[Снимок экрана 2025-11-11 в 01.11.31.png]]
Обнаруживаем, что в полезную нагрузку входит идентификатор пользователя (user_id),  
его имя (username) и время жизни токена (exp)
![[Снимок экрана 2025-11-11 в 01.12.27.png]]
Зафиксируем этот момент, ещё к нему вернёмся. Проанализируем далее исходный код на странице /content. Обнаруживаем запрос на /api/v1/getobject?id=${userId}.

Это тот самый идентификатор из полезной нагрузки токена, попробуем перебрать этот идентификатор в запросе.  
Через BurpSuite
![[Снимок экрана 2025-11-11 в 01.13.42.png]]
Исходный запрос выглядит так, если ничего не добавляли:
![[Снимок экрана 2025-11-11 в 01.14.50.png]]
Меняем идентификатор user_id, например, на 1 и отправляем запрос
![[Снимок экрана 2025-11-11 в 01.15.48.png]]
Обнаруживаем сообщение об ошибке, что контент  для пользователя с идентификатором 1 не принадлежит пользователю 2. Поменяем в токене этот идентификатор
![[Снимок экрана 2025-11-11 в 01.16.33.png]]
Получаем ошибку, так как подпись невалидна, тогда попробуем проверить Alg None Attack.
![[Снимок экрана 2025-11-11 в 01.17.41.png]]
Отлично, на back-end части при передаче в header токена alg=none подпись не проверяется и токен считаем валидным.

Мы получили содержимое пользователя 1.

Для визуального отображения ответа берем токен из запроса и подставляем его на ручку /content
![[Снимок экрана 2025-11-11 в 01.20.59.png]]
Далее открываем ответ в браузере