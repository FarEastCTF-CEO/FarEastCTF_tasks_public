import math
from typing import Tuple, Iterator, Iterable, Optional

def continuous_decomposition(x: int, y: int)-> Iterator[int]:# непрерывное разложение усложено так как для больших чисел
    while y:
        a = x // y
        yield a
        x, y = y, x - a * y

def suitable_fractions(arr_suitable_fractions: Iterable[int]) -> Iterator[Tuple[int, int]]:# подходящие дроби усложено так как для больших чисел
    n0, d0 = 0, 1
    n1, d1 = 1, 0
    for q in arr_suitable_fractions:
        n = q * n1 + n0
        d = q * d1 + d0
        yield n, d
        n0, d0 = n1, d1
        n1, d1 = n, d

def attack(e: int, n: int) -> Optional[int]:
    c_d = continuous_decomposition(e, n)
    c_f = suitable_fractions(c_d)
    print("хотите увидеть непрерывное разложение для e/m, введите: Y в обратном случае N")
    if input() == "Y":
        print(f"непрерывное разложение: {list(continuous_decomposition(e, n))}")
    print("хотите увидеть подходящие дроби для e/m, введите: Y в обратном случае N")
    if input() == "Y":
        print(f"подходящие дроби: {list(suitable_fractions(continuous_decomposition(e, n)))}")
    for k, d in c_f:
        if k>0 :
            phi = e * d // k
            x = n - phi + 1  # p+q замечание 2 атака винера
            if x % 2 == 0 and math.isqrt((x // 2) ** 2 - n)**2 ==(x // 2) ** 2 - n:  # y -> (p-q)/2
                x = x // 2
                y = math.isqrt(x ** 2 - n)
                p = x + y
                q = x - y
                return p,q,d
        else: continue
    return None

contin =True
while (contin):
    e = 30749686305802061816334591167284030734478031427751495527922388099381921172620569310945418007467306454160014597828390709770861577479329793948103408489494025272834473555854835044153374978554414416305012267643957838998648651100705446875979573675767605387333733876537528353237076626094553367977134079292593746416875606876735717905892280664538346000950343671655257046364067221469807138232820446015769882472160551840052921930357988334306659120253114790638496480092361951536576427295789429197483597859657977832368912534761100269065509351345050758943674651053419982561094432258103614830448382949765459939698951824447818497599
    m = 109966163992903243770643456296093759130737510333736483352345488643432614201030629970207047930115652268531222079508230987041869779760776072105738457123387124961036111210544028669181361694095594938869077306417325203381820822917059651429857093388618818437282624857927551285811542685269229705594166370426152128895901914709902037365652575730201897361139518816164746228733410283595236405985958414491372301878718635708605256444921222945267625853091126691358833453283744166617463257821375566155675868452032401961727814314481343467702299949407935602389342183536222842556906657001984320973035314726867840698884052182976760066141
    p,q,d=attack(e,m)
    fi = (p-1)*(q-1)    # ed =1 (mod fi) -> ed = 1 + k*fi
    print(f"параметры шифра: \np = {p} \nq = {q} \nd = {d} \nfi = {fi} \ne = {e} \nm = {m}")
    print("хотите дальше использовать программу нажмите Y в обратном случае N")
    contin = True if input() == "Y" else False

