# Решение

## Наблюдения
Бинарь просит `Enter key:` и принимает строку в hex. Длина - 128 символов, то есть 64 байта после декодирования.
Внутри лежит матрица 64x64 из 0 и 1. По ней строится цепочка длиной 64, которая удовлетворяет ограничениям по mutex маскам.

## Получение ключа
1. Открываем бинарь в IDA/Ghidra и находим в .data матрицу 64x64 байт.
2. Экспортируем ее в скрипт и рекурсивно строим цепочку длиной 64, каждый раз проверяя, что новый элемент не конфликтует с текущей маской.

В результате находятся два валидных ключа. Первый приводит к фейковому `flag{...}`, второй - к нужному.

## Проверка
Запускаем бинарь и вводим второй ключ:
```bash
./permutations
Enter key:
3c2c00121f2515263a1e39182a3f2f0d0b35233327193e340a2d1d282236202b021a3807033117160f3b13043d3011102e0601051c2129240e140c1b32093708
```

Вывод:
```
Congrats! Here's some totally random data: flag{c0ngr4tZ!_waS_eZ_r1Gh7?_h0p4_s0!}
```

Формат платформы - `FECTF{...}`, значит итоговый флаг:
`FECTF{c0ngr4tZ!_waS_eZ_r1Gh7?_h0p4_s0!}`

## Примечание
Фейковый ключ, который печатает `flag{y0u_4r3_cL0z_bu7_i7S_a_f4Ke_fl4g}`:
`083709321b0c140e2429211c0501062e1011303d04133b0f1617310307381a022b203622281d2d0a343e19273323350b0d2f3f2a18391e3a2615251f12002c3c`